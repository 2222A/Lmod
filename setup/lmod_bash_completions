_module_avail() {
	@PKG@/libexec/lmod bash -t avail  2>&1 > /dev/null | sed ' /:$/d; s#/*$##g;'
}

_module_loaded() {
	@PKG@/libexec/lmod bash -t list  2>&1 > /dev/null | sed ' /^ *$/d; /:$/d; s#/*$##g;'
}

_module_not_yet_loaded() {
	comm -23  <(_module_avail|sort)  <(_module_loaded|sort)
}

_module_long_arg_list() {
	local cur="$1" i

	if [[ ${COMP_WORDS[COMP_CWORD-2]} == sw* ]]
	then
		COMPREPLY=( $(compgen -W "$(_module_not_yet_loaded)" -- "$cur") )
		return
	fi
	for ((i = COMP_CWORD - 1; i > 0; i--))
	do case ${COMP_WORDS[$i]} in
	   add|load)
		COMPREPLY=( $(compgen -W "$(_module_not_yet_loaded)" -- "$cur") )
		break;;
	   rm|remove|unload|switch|swap)
		COMPREPLY=( $(compgen -W "$(_module_loaded)" -- "$cur") )
		break;;
	   esac
	done
}

_module() {
	local cur="$2" prev="$3" cmds opts

	COMPREPLY=()

	cmds="add avail delete help keyword list load purge rm restore save show spider swap \
	      unload unuse update use whatis"

	opts="-d -h -q -t -\
	      --expert --help  --quiet --terse --version"

	case "$prev" in
	add|load)	COMPREPLY=( $(compgen -W "$(_module_not_yet_loaded)" -- "$cur") );;
	rm|remove|unload|switch|swap)
			COMPREPLY=( $(      compgen -W "$(_module_loaded)" -- "$cur") );;
	unuse)		COMPREPLY=( $(IFS=: compgen -W "${MODULEPATH}" -- "$cur") );;
	use|*-a*)	;;			# let readline handle the completion
	help|show|whatis)
			COMPREPLY=( $(compgen -W "$(_module_avail)" -- "$cur") );;
	*) if test $COMP_CWORD -gt 2
	   then
		_module_long_arg_list "$cur"
	   else
		case "$cur" in
		# The mappings below are optional abbreviations for convenience
		ls)	COMPREPLY="list";;	# map ls -> list
		sw*)	COMPREPLY="swap";;

		-*)	COMPREPLY=( $(compgen -W "$opts" -- "$cur") );;
		*)	COMPREPLY=( $(compgen -W "$cmds" -- "$cur") );;
		esac
	   fi;;
	esac
}
complete -o default -F _module module

# Local Variables:
# mode: shell-script
# End:
