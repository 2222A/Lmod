\documentclass{beamer}

\usetheme[headernav]{TACC} %%Drop the 'headernav' if you don't like
                           %%the stuff at the top of your slide

\usepackage{amsmath,amssymb,amsthm}
\usepackage{alltt}
\usepackage{graphicx}

\title{Lmod: A New Environment Modules System for HPC}


\author{Robert McLay}
\institute{The Texas Advanced Computing Center}

\date{August 30, 2011}  %% Use this if you want to fix the date in
                        %% stone rather than use \today

\newcommand{\bfnabla}{\mbox{\boldmath$\nabla$}}
\newcommand{\laplacian}[1]{\bfnabla^2 #1}
\newcommand{\grad}[1]{\bfnabla #1}
\newcommand{\tgrad}[1]{\bfnabla^T #1}
\newcommand{\dvg}[1]{\bfnabla \cdot #1}
\newcommand{\curl}[1]{\bfnabla \times #1}
\newcommand{\lap}[1]{\bfnabla^2 #1}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Introduction}

\begin{frame}{Introduction}
  \begin{itemize}
    \item Fundamental Issues
    \item Environment Modules
    \item Software Hierarchy
    \item Lmod
    \item Conclusions
  \end{itemize}
\end{frame}


\begin{frame}{Fundamental Issues}
  \begin{itemize}
    \item Software Packages are created and updated all the time.
    \item Some Users need new versions for new features and bug fixes.
    \item Other Users need older versions for stability and continuity.
    \item No system can support all versions of all packages.
    \item User programs using pre-built C++ \& Fortran libraries must
      link with the same compiler.
    \item Similarly, MPI Applications must build and link with same
      MPI/Compiler pairing when using prebuilt MPI libraries.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example of Lmod: Environment Modules}
    {\tiny
\begin{alltt}
{\color{blue}ranger\$ module list}
Currently Loaded Modules:
  1) Linux  2) cluster  3) TACC  4) pgi/7.2-5  5) mvapich2/1.2  6) petsc/3.1
{\color{blue}ranger\$ module unload pgi}
Inactive Modules:
  1) mvapich2  2) petsc
{\color{blue}ranger\$ module list}
Currently Loaded Modules:
  1) Linux  2) cluster  3) TACC
Inactive Modules:
  1) mvapich2  2) petsc
{\color{blue}ranger\$ module load intel}
Activating Modules:
  1) mvapich2  2) petsc
{\color{blue}ranger\$ module swap intel pgi}
Due to MODULEPATH changes the follow modules have been reloaded:
  1) mvapich2  2) petsc
\end{alltt}
    }
\end{frame}

\begin{frame}{Lmod vs. TCL/C modules}

  \begin{itemize}
    \item Lmod provides all the functionality that TCL/C Modules does.
    \item It direct support for Software Hierarchy.
    \item It reads both TCL and Lua based modulefiles.
    \item It can finding all modules available via {\color{blue}module spider}.
    \item Users can set their default set of modules via
      {\color{blue}module  setdefault}.
  \end{itemize}
\end{frame}



\begin{frame}{TACC Environment}
  \begin{itemize}
    \item TACC: Texas Advanced Computing Center
    \item Ranger: 62K cores, 580Tflops, 779 Packages
    \item Lonestar: 22K Cores, 302Tflops, 162 Packages
    \item Longhorn: 256 Node, 512 GPUs, 158 Packages
    \item My Work Laptop: 98 Packages.
  \end{itemize}
\end{frame}

\begin{frame}{Enviroment Modules }
  \begin{itemize}
    \item The ``module'' command ``loads'' a package.
    \item It adds directories to \texttt{PATH} or \texttt{LD\_LIBRARY\_PATH} and
      sets env. vars.
    \item ``\texttt{module unload} \emph{package}'' removes all packages
      changes: \texttt{PATH}, \texttt{LD\_LIBRARY\_PATH}, unset vars.
    \item A module file is a text file containing shell-independent commands:
      \begin{itemize}
        \item \texttt{prepend\_path("PATH","/opt/apps/git/1.8/bin")}
        \item \texttt{setenv("TACC\_GIT\_DIR","/opt/apps/git/1.8")}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Modules and Versions}
  \begin{itemize}
    \item Modules are typically named: \emph{package/version}
    \item For example: \texttt{git/1.8}
    \item There is a default version so:
    \item ``\texttt{module load git}'' load the default version.
    \item ``\texttt{module load git/1.8}'' load the 1.8 version.
  \end{itemize}
\end{frame}

\begin{frame}{Sys-admin Vs. User Control of software}
  \begin{itemize}
    \item Sys-admins control what versions are default.
    \item Users can override defaults to newer/older versions.
    \item When Compilers are updated, users can switch between
      versions, allowing for testing.
    \item This is the key to a flexible system.
  \end{itemize}
\end{frame}

\begin{frame}{Enviroment Modules History}
  \begin{itemize}
    \item Paper described modules in 1991 (Furlani).
    \item Cray used modules on Unicos mid-1990's.
    \item TACC has been using modules since our 1st Cray T3E in the
      late 90's.
  \end{itemize}
\end{frame}

\begin{frame}{Enviroment Modules History (II)}
  \begin{itemize}
    \item At some point Environment Modules was written in TCL/C combination.
    \item Another module system called CMOD:
      //www.lysator.liu.se/cmod/ (1997-1998)
    \item www.modules.org: TCL/C Module files written in TCL (Late '90 - now)
    \item A pure TCL based module system: www.modules.org (? - now) 
    \item Lmod: Lua Based Module  (2008 - now)
  \end{itemize}
\end{frame}

\begin{frame}{How could modules possibly work?}
  \begin{itemize}
    \item Child processes inherit the parents enviroment.
    \item Not the other way around.
    \item So how does this work?
  \end{itemize}
\end{frame}

\begin{frame}{The Trick}
  \begin{itemize}
    \item The module command \texttt{lmod\_cmd} reads module files
    \item $\Rightarrow$ shell dependent text
    \item In bash:
      \begin{itemize}
          \item \texttt{module () \{ eval \$(\$LMOD\_CMD bash "\$@")\}}
      \end{itemize}
    \item In csh \texttt{module} is an alias:
      \begin{itemize}
        \item \texttt{alias module eval `\$LMOD\_CMD csh $\backslash$!*`}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Trick (II)}
    Text output of the module command:
    \begin{itemize}
      \item modulefile ``foo/1.0.lua'':
    {
\begin{verbatim}
          setenv("FOO_VERSION","1.0")
\end{verbatim}
    }
     \item Output for bash:
\begin{verbatim}
          export FOO_VERSION="1.0"
\end{verbatim}
     \item Output for csh:
\begin{verbatim}
          setenv FOO_VERSION "1.0"
\end{verbatim}
    \end{itemize}
\end{frame}

\section{Software Hierarchy}

\begin{frame}{Software Hierarchy}
  \begin{itemize}
    \item TACC used modules from www.modules.org (TCL/C) modules
    \item Life was good at TACC until ...
    \item Multiple Compilers and Multiple MPI implementations.
    \item Pre-built C++ \& Fortran libraries must link with the same compiler
    \item Similarly MPI Applications must build and link with same
      MPI/Compiler pairing.
  \end{itemize}
\end{frame}

\begin{frame}{Modulefile Choices}
  \begin{itemize}
    \item Flat Naming Scheme
    \item Hierarchical Naming Scheme
  \end{itemize}
\end{frame}

\begin{frame}{Flat Naming Scheme: PETSc}
  \begin{itemize}
    \item Compilers: GCC 4.5, Intel 11.1
    \item MPI Implementations: MVAPICH 1.2, Openmpi 1.5
    \item MPI Solver package: PETSc 4.1
    \item 4 versions of PETSc: 2 Compilers $\times$ 2 MPI 
  \end{itemize}
\end{frame}

\begin{frame}{Flat: PETSc }
  \begin{enumerate}
  \item \texttt{PETSc-4.1-mvapich-1.2-gcc-4.5}
  \item \texttt{PETSc-4.1-mvapich-1.2-intel-11.1}
  \item \texttt{PETSc-4.1-openmpi-1.5-gcc-4.5}
  \item \texttt{PETSc-4.1-openmpi-1.5-intel-11.1}
  \end{enumerate}
\end{frame}

\begin{frame}{Problems w/ Flat naming scheme}
  \begin{itemize}
    \item Users have to load modules:
      \begin{itemize}
        \item ``intel-11.1''
        \item ``mvapich-1.2-intel-11.1''
        \item ``PETSc-4.1-mvapich-1.2-intel-11.1''
        \item Changing compilers means unloading all three modules
        \item Reloading new compiler, mpi, PETSc modules.
        \item Not loading correct modules $\Rightarrow$ Mysterious Failures!
        \item Onus of package compatibility on users! 
      \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}{Hierarchical Naming Scheme}
  \begin{itemize}
    \item Store modules under one tree: \texttt{/opt/apps/modulefiles}
    \item Subdirectories:
      \begin{itemize}
        \item Core: Regular packages: apps, compilers, git
        \item Compiler: Packages that depend on compiler: boost, mpi
        \item MPI: Packages that depend on MPI/Compiler: PETSc, TAU, 
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Hierarchical Examples: Core}
  \begin{itemize}
    \item Generic:
      \begin{itemize}
        \item Package: \texttt{/opt/apps/}\emph{package/version}
        \item Modulefile: \texttt{/opt/apps/modulefiles/}\emph{package/version}
      \end{itemize}
    \item Git 1.8
      \begin{itemize}
        \item package location: \texttt{/opt/apps/git/1.8}
        \item Modulefile: \texttt{/opt/apps/modulefiles/Core/git/1.8}
      \end{itemize}
    \item Intel compilers 11.1
      \begin{itemize}
        \item package location: \texttt{/opt/apps/intel/11.1}
        \item Modulefile: \texttt{/opt/apps/modulefiles/Core/intel/11.1}
        \item Modulefile adds \texttt{/opt/apps/modulefiles/Compiler/intel/11.1} to \texttt{MODULEPATH}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Hierarchical Examples: Compiler Dependent}
  \begin{itemize}
    \item Generic:
      \begin{itemize}
        \item Package: /opt/apps/\emph{compiler-version/package/version}
        \item M: /opt/apps/modulefiles
        \item Modulefile: \texttt{\$M/Compiler/}\emph{compiler/version/package/version}
      \end{itemize}
    \item Openmpi 1.5
      \begin{itemize}
        \item Package: \texttt{/opt/apps/gcc-4\_5/openmpi/1.5}
        \item Modulefile: \texttt{\$M/Compiler/gcc/4.5/openmpi/1.5}
        \item Modulefile adds \texttt{\$M/MPI/gcc/4.5/openmpi/1.5}
          to \texttt{MODULEPATH}
        \item
        \item Package: \texttt{/opt/apps/intel-11\_1/openmpi/1.5}
        \item Modulefile: \texttt{\$M/Compiler/intel/11.1/openmpi/1.5}
        \item Modulefile adds \texttt{\$M/MPI/intel/11.1/openmpi/1.5}
          to \texttt{MODULEPATH}
          
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Hierarchical Examples: MPI/Compiler Dependent}
  \begin{itemize}
    \item PETSc 4.1 (1)
      \begin{itemize}
        \item Package: /opt/apps/intel-11\_1/openmpi-1\_5/petsc/4.1
        \item Modulefile: \texttt{\$M/MPI/intel/11.1/openmpi/1.5/petsc/4.1}
      \end{itemize}
    \item PETSc 4.1 (2)
      \begin{itemize}
        \item Package: /opt/apps/gcc-4\_5/mvapich-1\_2/petsc/4.1
        \item Modulefile: \texttt{\$M/MPI/gcc/4.5/mvapich/1.2/petsc/4.1}
      \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}{Loading the correct module}
  \begin{itemize}
    \item User loads ``intel/11.1'' module
    \item Can only see/load compiler dependent packages that are built with
      intel 11.1 compiler.
    \item Can not see/load package built with other versions or other compilers.
    \item Similar loading ``openmpi/1.5'' module.
    \item $\Rightarrow$ User can only load package that are built w/ intel 11.1 and openmpi 1.5 and no others.
  \end{itemize}
\end{frame}

\section{Lmod}

\begin{frame}{Better but ...}
  \begin{itemize}
    \item Using TCL/C modules, Users can only load correct modules
    \item Swapping compilers or MPI stack $\Rightarrow$ complicated!
    \item For Parallel libraries like PETSc:
      \begin{itemize}
        \item Users must unload PETSc, mpi, compiler
        \item Reload compiler, mpi, PETSc
        \item Nobody got this right!
      \end{itemize}
    \item Solution: Yet another Environment Module System: \texttt{Lmod}
  \end{itemize}
\end{frame}

\begin{frame}{Lmod}
  \begin{itemize}
    \item Complete Rewrite of the Environment Modules System.
    \item Reads TCL modulefiles.
    \item Based on the Lua scripting language.
    \item Simple yet powerful with:
      \begin{itemize}
        \item Functions are first class object.
        \item Simpifies loading/unloading of modules
        \item Tables combine array and hash seamlessly.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Key Insight (I): \texttt{MODULEPATH}}
  \begin{itemize}
    \item Lmod remembers the current state of \texttt{MODULEPATH}.
    \item If it changes then it unloads any modules not in current
      search path $\Rightarrow$ inactive.
    \item It tries to activate any inactive modules.
    \item It remembers inactive modules.
    \item It attempts to active any inactive modules on future invocations.
  \end{itemize}
\end{frame}

\begin{frame}{Key Insight (II): \texttt{MODULEPATH}}
  \begin{itemize}
    \item Loading gcc/4.5 and boost/1.47.1
      \begin{itemize}
        \item Adds \texttt{/opt/apps/modulefiles/Compiler/gcc/4.5} to
          \texttt{MODULEPATH}.
        \item Boost: \texttt{/opt/apps/modulefiles/Compiler/gcc/4.5/boost/1.47.1}
      \end{itemize}
    \item Unloading gcc/4.5
      \begin{itemize}
        \item Removes \texttt{/opt/apps/modulefiles/Compiler/gcc/4.5}
          from \texttt{MODULEPATH}.
        \item Inactivates boost/1.47.1
      \end{itemize}
    \item Loading intel/11.1
      \begin{itemize}
        \item Adds \texttt{/opt/apps/modulefiles/Compiler/intel/11.1} to
          \texttt{MODULEPATH}.
        \item Activates Boost: \texttt{/opt/apps/modulefiles/Compiler/intel/11.1/boost/1.47.1}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Other Safety Features of Lmod (I)}
  \begin{itemize}
    \item Users can only load one version of package.
    \item ``\texttt{module load xyz/2.1}'' loads xyz version 2.1
    \item ``\texttt{module load xyz/2.2}'' unloads 2.1, loads 2.2
  \end{itemize}
\end{frame}

\begin{frame}{Other Safety Features of Lmod (II)}
  \begin{itemize}
    \item Lmod adds a new command in modulefiles: \texttt{family("}\emph{name}\texttt{")}
    \item All of our compiler modules have \texttt{family("compiler")}
    \item All of our MPI modules have \texttt{family("MPI")}
    \item Users can only load one compiler or MPI at a time
    \item Powers users can get around restriction.
  \end{itemize}
\end{frame}

\subsection{Searching for Modules}
\label{sec:search}


\begin{frame}{Searching for Modules}
  \begin{itemize}
    \item Two ways to search for modules:
      \begin{itemize}
        \item ``\texttt{module avail}''
        \item ``\texttt{module spider}''
      \end{itemize}
    \item The ``\texttt{avail}''  command reports all ``loadable'' modules.
    \item The ``\texttt{spider}'' command reports all possible modules.
    \item What is the difference?
  \end{itemize}
\end{frame}

\begin{frame}{Module avail}
  \begin{itemize}
    \item ``avail'' only reports modules that are loadable w/ current
      MPI/Compiler pairing.
    \item A parallel library may not be built for all possible pairings.
    \item Won't always show with avail.
    \item Not all package can be build or work with all compiler/MPI suites.
  \end{itemize}
\end{frame}

\begin{frame}{Module spider}
  \begin{itemize}
    \item Reports all modules for given \texttt{MODULEPATH}.
    \item It walks the tree to find all branches.
    \item Large systems of modules save a cache file that is saved for
      a day.
    \item Three modes:
      \begin{itemize}
        \item module spider - all possible modules no detail.
        \item module spider petsc - all version of petsc, no detail.
        \item module spider petsc/3.1 - detail.
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Installing Lmod}
\label{sec:installing}

\begin{frame}{Installation Overview}
  \begin{itemize}
    \item Chose a place for module tree: ``\texttt{/opt/apps/modulefiles}''
    \item Use configure to override default.
    \item Install lua and Lmod applications
    \item Place module command in system shell startup.
    \item Possibly modify bash's startup procedure
    \item Design a default set of modules for your users.
  \end{itemize}
\end{frame}


\begin{frame}{Installing Lmod (I)}
  \begin{itemize}
    \item Download files from lmod.sf.net
      \begin{itemize}
        \item lua-x.y.z.tar.gz
        \item lmod-x.y.z.tar.gz
      \end{itemize}
    \item Assume all ``optional'' packages are in ``\texttt{/opt/apps/}''
    \item Install lua in \texttt{/opt/apps/lua/}\emph{x.y.z}''
    \item ``\texttt{\$ ln -s }\emph{x.y.z} \texttt{/opt/apps/lua/lua}''
    \item This way ``\texttt{/opt/apps/lua/lua/bin/lua}'' always points to
      lua independent of version.
  \end{itemize}
\end{frame}

\begin{frame}{Installing Lmod (II)}
  \begin{itemize}
    \item Install Lmod in ``\texttt{/opt/apps/lmod/}\emph{x.y.z}''
    \item ``\texttt{make install}'' creates a symlink from
      ``\emph{x.y.z}'' to lmod.
    \item This way ``\texttt{/opt/apps/lmod/lmod/...}'' always points
      to the latest lmod.
  \end{itemize}
\end{frame}

\begin{frame}{Integrating Lmod into User's Shell (I)}
    We must add the module alias for all user's shells by either link
    or copy:
    \begin{itemize}
      \item \texttt{\$ ln -s /opt/apps/lmod/lmod/init/profile /etc/profile.d/modules.sh}
      \item \texttt{\$ ln -s /opt/apps/lmod/lmod/init/cshrc   /etc/profile.d/modules.csh}
      \item You may have to create ``\texttt{/etc/profile.d}'' first.
  \end{itemize}
\end{frame}

\begin{frame}{Bash Shell startup files}
    \begin{tabular}{|l|l|l|}
        \hline
        ~           & System       & User \\\hline\hline
        login       & /etc/profile & $\sim$/.bash\_profile $\parallel$ $\sim$/.profile, ...\\\hline
        interactive & {\color{red}/etc/bashrc}$^\star$  & $\sim$/.bashrc\\\hline
        non-interactive & \$BASH\_ENV  & ~\\\hline
    \end{tabular}
    ~\\
    ~\\
    $^\star$ Not always built-in!\\
    \$BASH\_ENV points to a file which is run on  non-interactive shells.
\end{frame}

\begin{frame}{Csh Shell startup files}
{\small
    \begin{tabular}{|l|l|l|}
        \hline
        ~           & System       & User \\\hline\hline
        login       & /etc/csh.cshrc \& /etc/csh.login &  $\sim$/.cshrc  \& $\sim$/.login\\\hline
        interactive & /etc/csh.cshrc  & $\sim$/.cshrc\\\hline
        non-interactive & /etc/csh.cshrc & $\sim$/.cshrc~\\\hline
    \end{tabular}
}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Linux /etc/profile}
    {
\begin{verbatim}
if [ -d /etc/profile.d ]; then
  for i in /etc/profile.d/*.sh; do
    if [ -r $i ]; then
      . $i
    fi
  done
fi
\end{verbatim}
    }
\end{frame}


\begin{frame}[fragile]
    \frametitle{Linux /etc/bashrc}
    {
\begin{verbatim}
if ! shopt -q login_shell; then
  if [ -d /etc/profile.d ]; then
    for i in /etc/profile.d/*.SH; do
      if [ -r $i ]; then
        . $i
      fi
    done
  fi
fi
\end{verbatim}
    }
\end{frame}

\begin{frame}[fragile]
    \frametitle{Linux /etc/csh.cshrc}
    {
\begin{verbatim}
if ( -d /etc/profile.d ) then
  set nonomatch
  foreach i ( /etc/profile.d/*.csh )
     if ( -r $i ) then
       if ($?prompt) then
         source $i
       else
         source $i >& /dev/null
       endif
    endif
  end
endif
\end{verbatim}
    }
\end{frame}

\begin{frame}{Rebuilding Bash to use /etc/bashrc}
  \begin{itemize}
    \item By default bash does not read /etc/bashrc
    \item Red Hat, Centos,  Mac OS X, don't read /etc/bashrc
    \item We at TACC rebuild bash so that it does read /etc/bashrc
    \item You must patch config-top.h to change bash's behavior.
    \item We want bash interactive shells to behave the same as login shells.
  \end{itemize}
\end{frame}

\begin{frame}{Loading Default Modules}
  \begin{itemize}
    \item At TACC, all users get a default set of module loaded at startup.
    \item In ``\texttt{/etc/profile.d/z96\_login\_modules.sh}:'' \\
      {\color{blue}\texttt{module getdefault default || module load TACC}}
    \item Most users get the ``TACC'' set of modules
    \item We load standard tools, a compiler, an mpi implementation.
    \item User can replace the default via ``{\color{blue}\texttt{module setdefault}}''
  \end{itemize}
\end{frame}

\begin{frame}{Modules and Package Management at TACC}
  \begin{itemize}
    \item All of the ``optional'' software: compilers, MPI Stacks,
      Libraries, and Applications are install via the RPM package management.
    \item We create our optional RPMs with both the software and the
      module files.
    \item Uninstalling a package removes both the software and the
      module that access it.
    \item We use a single parameterized spec file to build all
      compiler/mpi pairing.
  \end{itemize}
\end{frame}

\begin{frame}{Management of Modules}
  \begin{itemize}
    \item Encourage users to use modules with their own software.
    \item Check modulefile syntax errors by running:
      \{\color{blue}module spider}
    \item Use {\color{green}\texttt{prereq("foo","bar")} instead of
      {\color{green}\texttt{load("foo","bar")}
    \item Use  {\color{green}\texttt{family("compiler")} and similar
      in your compiler and MPI module files.
  \end{itemize}
\end{frame}

\begin{frame}{Making modules work with setdefault}
  \begin{itemize}
    \item A module file should only be either a manager module or
      a worker module.
    \item A worker module is one that only sets environment variables.
    \item A manager module loads other modules.
    \item For complicated reasons setdefault/getdefault requires that
      no module being saved is both a manager and a worker modulefile.
  \end{itemize}
\end{frame}


\section{Conclusion}

\begin{frame}{Conclusion}
  \begin{itemize}
    \item lmod.sourceforge.net (lmod.sf.net)
    \item www.tacc.utexas.edu/tacc-projects/mclay/lmod
  \end{itemize}
\end{frame}




\end{document}
