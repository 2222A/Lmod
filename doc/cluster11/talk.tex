\documentclass{beamer}

\usetheme[headernav]{TACC} %%Drop the 'headernav' if you don't like
                           %%the stuff at the top of your slide

\usepackage{amsmath,amssymb,amsthm}
\usepackage{alltt}
\usepackage{graphicx}

\title{Lmod: A New Environment Modules System for HPC}


\author{Robert McLay}
\institute{The Texas Advanced Computing Center}

\date{August 30, 2011}  %% Use this if you want to fix the date in
                        %% stone rather than use \today

\newcommand{\bfnabla}{\mbox{\boldmath$\nabla$}}
\newcommand{\laplacian}[1]{\bfnabla^2 #1}
\newcommand{\grad}[1]{\bfnabla #1}
\newcommand{\tgrad}[1]{\bfnabla^T #1}
\newcommand{\dvg}[1]{\bfnabla \cdot #1}
\newcommand{\curl}[1]{\bfnabla \times #1}
\newcommand{\lap}[1]{\bfnabla^2 #1}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Introduction}

\begin{frame}{Introduction}
  \begin{itemize}
    \item Fundamental Issues
    \item Environment Modules
    \item Software Hierarchy
    \item Lmod
    \item Conclusions
  \end{itemize}
\end{frame}


\begin{frame}{Fundamental Issues}
  \begin{itemize}
    \item Software Packages are created and updated all the time.
    \item Some Users need new versions for new features and bug fixes.
    \item Other Users need older versions for stability and continuity.
    \item No system can support all versions of all packages.
    \item User programs using pre-built C++ \& Fortran libraries must
      link with the same compiler.
    \item Similarly, MPI Applications must build and link with same
      MPI/Compiler pairing when using prebuilt MPI libraries.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example of Lmod: Environment Modules (I)}
    {\tiny
\begin{alltt}
\$ {\color{blue} module avail}
------------------ /opt/apps/modulefiles/MPI/intel/12.0/mpich2/1.4 ------------------
  petsc/3.1 (default)    petsc/3.1-debug    pmetis/4.0    tau/2.20.3  

------------------- /opt/apps/modulefiles/Compiler/intel/12.0 -----------------------
  boost/1.45.0              gotoblas2/1.13          openmpi/1.4.3  
  boost/1.46.0              mpich2/1.3.2            openmpi/1.5.1  
  boost/1.46.1 (default)    mpich2/1.4 (default)    openmpi/1.5.3 (default)  

-------------------------- /opt/apps/modulefiles/Core -------------------------------
  PrgEnv               intel/11.1               papi/4.1.4  
  admin/admin-1.0      intel/12.0 (default)     scite/2.28
  ddt/ddt              lmod/lmod                tex/2010  
  dmalloc/dmalloc      local/local (default)    unix/unix (default)                       
  fdepend/1.2          mkl/mkl                  visit/visit  
  gcc/4.4              noweb/2.11b             
  gcc/4.5 (default)                     
\end{alltt}
    }
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example of Lmod: Environment Modules (II)}
    {\tiny
\begin{alltt}
{\color{blue}\$ module list}
Currently Loaded Modules:
  1) PrgEnv  2) gcc/4.5  3) mpich2/1.4  4) petsc/3.1
{\color{blue}\$ module unload gcc}
Inactive Modules:
  1) mpich2  2) petsc
{\color{blue}\$ module list}
Currently Loaded Modules:
  1) PrgEnv
Inactive Modules:
  1) mpich2  2) petsc
{\color{blue}\$ module load intel}
Activating Modules:
  1) mpich2  2) petsc
{\color{blue}\$ module swap intel gcc}
Due to MODULEPATH changes the follow modules have been reloaded:
  1) mpich2  2) petsc
\end{alltt}
    }
\end{frame}


\begin{frame}{Benefits of Modules}
  \begin{itemize}
    \item Users do not need to know where software is installed
    \item Environment Variables to interface package can be set:
      \begin{itemize}
        \item TACC\_{\color{blue}\emph{PACKAGE}}\_LIB
        \item TACC\_{\color{blue}\emph{PACKAGE}}\_INC
        \item User do not need to set hardcoded paths.
      \end{itemize}
    \item Package required variables such as \texttt{LICENSE\_PATH}
      can be set automatically.
  \end{itemize}
\end{frame}


\begin{frame}{Benefits of Lmod vs. TCL/C modules}

  \begin{itemize}
    \item Lmod provides all the functionality that TCL/C Modules does.
    \item Directly support for Software Hierarchy.
    \item It reads both TCL and Lua based modulefiles.
      \begin{itemize}
        \item Lua module files have ``\texttt{.lua}'' extension.
        \item TCL module files don't.
      \end{itemize}
    \item Users can find all modules available via {\color{blue}module spider}.
    \item Users can set their default set of modules via
      {\color{blue}module  setdefault}.
  \end{itemize}
\end{frame}



\begin{frame}{TACC Environment}
  \begin{itemize}
    \item TACC: Texas Advanced Computing Center
    \item Ranger: 62K cores, 580Tflops, 779 Packages
    \item Lonestar: 22K Cores, 302Tflops, 162 Packages
    \item Longhorn: 256 Node, 512 GPUs, 158 Packages
    \item My Work Laptop: 98 Packages.
  \end{itemize}
\end{frame}

\begin{frame}{Enviroment Modules}
  \begin{itemize}
    \item The ``module'' command ``loads'' a package.
    \item It adds directories to \texttt{PATH} or \texttt{LD\_LIBRARY\_PATH} and
      sets other  Variables. 
    \item ``\texttt{module unload} \emph{package}'' removes all packages
      changes: \texttt{PATH}, \texttt{LD\_LIBRARY\_PATH}, unset vars.
    \item A module file is a text file containing shell-independent commands:
      \begin{itemize}
        \item \texttt{prepend\_path("PATH","/opt/apps/git/1.8/bin")}
        \item \texttt{setenv("TACC\_GIT\_DIR","/opt/apps/git/1.8")}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Modules and Versions}
  \begin{itemize}
    \item Modules are typically named: \emph{package/version}
    \item For example: \texttt{git/1.8}
    \item There is a default version so:
      \begin{itemize}
        \item ``\texttt{module load git}'' load the default version.
        \item ``\texttt{module load git/1.8}'' load the 1.8 version.
      \end{itemize}
    \item Typically a module name is a directory name and the version
      is a file.
  \end{itemize}
\end{frame}

\begin{frame}{Sys-admin Vs. User Control of software}
  \begin{itemize}
    \item Sys-admins control what versions are default.
    \item Users can load newer/older versions instead of the default.
    \item When compilers are updated, users can switch between
      versions, allowing for testing.
    \item This is the key to a flexible system.
    \item Users can create their own modules for personal software.
  \end{itemize}
\end{frame}

\begin{frame}{Enviroment Modules History}
  \begin{itemize}
    \item Paper described modules in 1991 (Furlani).
    \item Cray used modules on Unicos mid-1990's.
    \item TACC has been using modules since our 1st Cray T3E in the
      late 90's.
  \end{itemize}
\end{frame}

\begin{frame}{Enviroment Modules History (II)}
  \begin{itemize}
    \item At some point Environment Modules was rewritten in a TCL/C combination.
    \item Another module system called CMOD:
      www.lysator.liu.se/cmod/ (1997-1998)
    \item www.modules.org: TCL/C Module files written in TCL (Late '90s - now)
    \item A pure TCL based module system: www.modules.org (? - now) 
    \item Lmod: Lua Based Environment Module System (2008 - now) (lmod.sf.net)
  \end{itemize}
\end{frame}

\begin{frame}{How could modules possibly work?}
  \begin{itemize}
    \item Child processes inherit the parents enviroment.
    \item Not the other way around.
    \item So how does this work?
  \end{itemize}
\end{frame}

\begin{frame}{The Trick}
  \begin{itemize}
    \item The module command {\color{blue}\texttt{\$LMOD\_CMD}} reads module files
    \item The program outputs shell dependent text.
    \item Second step: evaluate shell dependent text.
    \item In bash:
      \begin{itemize}
          \item {\color{blue}\texttt{module () \{ eval \$(\$LMOD\_CMD bash "\$@")\}}}
      \end{itemize}
    \item In csh \texttt{module} is an alias:
      \begin{itemize}
        \item {\color{blue}\texttt{alias module eval `\$LMOD\_CMD csh $\backslash$!*`}}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{The Trick (II)}
    Text output of the module command:
    \begin{itemize}
      \item modulefile ``foo/1.0.lua'':
    {
\begin{verbatim}
          setenv("FOO_VERSION","1.0")
\end{verbatim}
    }
     \item Output for bash:
\begin{verbatim}
          export FOO_VERSION="1.0"
\end{verbatim}
     \item Output for csh:
\begin{verbatim}
          setenv FOO_VERSION "1.0"
\end{verbatim}
    \end{itemize}
\end{frame}

\section{Software Hierarchy}

\begin{frame}{Software Hierarchy}
  \begin{itemize}
    \item TACC used modules from www.modules.org (TCL/C) modules
    \item Life was good at TACC until ...
    \item Multiple Compilers and Multiple MPI implementations.
    \item Pre-built C++ \& Fortran libraries must link with the same compiler
    \item Similarly MPI Applications must build and link with same
      MPI/Compiler pairing.
  \end{itemize}
\end{frame}

\begin{frame}{Modulefile Choices}
  \begin{itemize}
    \item Flat Naming Scheme
    \item Hierarchical Naming Scheme
  \end{itemize}
\end{frame}

\begin{frame}{Flat Naming Scheme: PETSc}
  PETSc is a parallel iterative solver package:
  \begin{itemize}
    \item Compilers: GCC 4.5, Intel 11.1
    \item MPI Implementations: MVAPICH 1.2, Openmpi 1.5
    \item MPI Solver package: PETSc 4.1
    \item 4 versions of PETSc: 2 Compilers $\times$ 2 MPI 
  \end{itemize}
\end{frame}

\begin{frame}{Flat: PETSc }
  \begin{enumerate}
  \item \texttt{PETSc-4.1-mvapich-1.2-gcc-4.5}
  \item \texttt{PETSc-4.1-mvapich-1.2-intel-11.1}
  \item \texttt{PETSc-4.1-openmpi-1.5-gcc-4.5}
  \item \texttt{PETSc-4.1-openmpi-1.5-intel-11.1}
  \end{enumerate}
\end{frame}

\begin{frame}{Problems w/ Flat naming scheme}
  \begin{itemize}
    \item Users have to load modules:
      \begin{itemize}
        \item ``intel/11.1''
        \item ``mvapich/1.2-intel-11.1''
        \item ``PETSc/4.1-mvapich-1.2-intel-11.1''
        \item Changing compilers means unloading all three modules
        \item Reloading new compiler, mpi, PETSc modules.
        \item Not loading correct modules $\Rightarrow$ Mysterious Failures!
        \item Onus of package compatibility on users! 
      \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}{Hierarchical Naming Schemes}
  \begin{itemize}
    \item Store modules under one tree: \texttt{/opt/apps/modulefiles}
    \item One strategy is to use subdirectories:
      \begin{itemize}
        \item Core: Regular packages: apps, compilers, git
        \item Compiler: Packages that depend on compiler: boost, mpi
        \item MPI: Packages that depend on MPI/Compiler: PETSc, TAU
      \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}{Hierarchical Naming Schemes (II)}
  \begin{itemize}
    \item TACC's strategy is:
      \begin{itemize}
        \item Core modules in /opt/apps/modulesfiles
        \item Compiler modules in
          /opt/apps/compiler-version/modulefiles: (/opt/apps/intel11\_1/modulefiles)
        \item MPI modules in
          /opt/apps/compiler-version/mpi-version/modulefiles: (/opt/apps/intel11\_1/mvapich2\_1\_6/modulefiles)
      \end{itemize}
    \item Do not do mix core modules in the same place as compiler and
      mpi/compiler dependent modules.
    \item I.E: Do not have:
      \begin{itemize}
        \item Core modules in /opt/apps/modulefiles
        \item Compiler dependent modules in /opt/apps/modulefiles/intel11\_1/modulefiles/boost/1.46.1
      \end{itemize}
      
  \end{itemize}
\end{frame}

\begin{frame}{\texttt{MODULEPATH}}
  \begin{itemize}
    \item \texttt{MODULEPATH} is a colon separated list of directories
      containing directories and module files.
    \item No modulefiles loaded $\Rightarrow$ users can only load core modules.
    \item Loading a compiler module adds to the \texttt{MODULEPATH}:
      \begin{itemize}
        \item Users can load compiler dependent modules.
        \item This includes MPI implementations modules.
      \end{itemize}
    \item Loading an MPI module adds to the \texttt{MODULEPATH}:
      \begin{itemize}
        \item Users can load MPI libraries that match the mpi/compiler pairing.
      \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}{Hierarchical Examples: Core}
  \begin{itemize}
    \item Generic:
      \begin{itemize}
        \item Package: \texttt{/opt/apps/}\emph{package/version}
        \item M: {\color{blue}/opt/apps/modulefiles}
        \item Modulefile: \texttt{{\color{blue}\$M}/Core/}\emph{package/version}
      \end{itemize}
    \item Git 1.8
      \begin{itemize}
        \item Package: \texttt{/opt/apps/git/1.8}
        \item Modulefile: \texttt{{\color{blue}\$M}/Core/git/1.8}
      \end{itemize}
    \item Intel compilers 11.1
      \begin{itemize}
        \item Package: \texttt{/opt/apps/Core/intel/11.1}
        \item Modulefile: \texttt{{\color{blue}\$M}/Core/intel/11.1}
        \item Modulefile adds \texttt{{\color{blue}\$M}/Compiler/intel/11.1} to \texttt{MODULEPATH}
      \end{itemize}
  \end{itemize}
\end{frame}



\begin{frame}{Hierarchical Examples: Compiler Dependent}
  \begin{itemize}
    \item Generic:
      \begin{itemize}
        \item Package: /opt/apps/\emph{compiler-version/package/version}
        \item M: {\color{blue}/opt/apps/modulefiles}
        \item Modulefile: \texttt{{\color{blue}\$M}/Compiler/}\emph{compiler/version/package/version}
      \end{itemize}
    \item Openmpi 1.5 with gcc 4.5
      \begin{itemize}
        \item Package: \texttt{/opt/apps/gcc-4\_5/openmpi/1.5}
        \item Modulefile: \texttt{{\color{blue}\$M}/Compiler/gcc/4.5/openmpi/1.5}
        \item Modulefile adds \texttt{{\color{blue}\$M}/MPI/gcc/4.5/openmpi/1.5}
          to \texttt{MODULEPATH} \\
      \end{itemize}          
    \item Openmpi 1.5 with intel 11.1
      \begin{itemize}
        \item Package: \texttt{/opt/apps/intel-11\_1/openmpi/1.5}
        \item Modulefile: \texttt{{\color{blue}\$M}/Compiler/intel/11.1/openmpi/1.5}
        \item Modulefile adds \texttt{\$M/MPI/intel/11.1/openmpi/1.5}
          to \texttt{MODULEPATH}
          
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Hierarchical Examples: MPI/Compiler Dependent}
  \begin{itemize}
    \item PETSc 4.1 (1)
      \begin{itemize}
        \item Package: /opt/apps/intel-11\_1/openmpi-1\_5/petsc/4.1
        \item Modulefile: \texttt{{\color{blue}\$M}/MPI/intel/11.1/openmpi/1.5/petsc/4.1}
      \end{itemize}
    \item PETSc 4.1 (2)
      \begin{itemize}
        \item Package: /opt/apps/gcc-4\_5/mvapich-1\_2/petsc/4.1
        \item Modulefile: \texttt{{\color{blue}\$M}/MPI/gcc/4.5/mvapich/1.2/petsc/4.1}
      \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}{Loading the correct module}
  \begin{itemize}
    \item User loads ``intel/11.1'' module
    \item Can only see/load compiler dependent packages that are built with
      intel 11.1 compiler.
    \item Can not see/load package built with other versions or other compilers.
    \item Similar loading ``openmpi/1.5'' module.
    \item $\Rightarrow$ User can only load package that are built w/ intel 11.1 and openmpi 1.5 and no others.
  \end{itemize}
\end{frame}

\section{Lmod}

\begin{frame}{Better but ...}
  \begin{itemize}
    \item Using TCL/C modules, Users can load correct modules by using
      the Software Hierarchy.
    \item But swapping compilers or MPI stack $\Rightarrow$ complicated!
    \item For Parallel libraries like PETSc:
      \begin{itemize}
        \item Users must unload PETSc, mpi, compiler
        \item Reload compiler, mpi, PETSc
        \item Nobody got this right!
      \end{itemize}
    \item Solution: Yet another Environment Module System: \texttt{Lmod}
  \end{itemize}
\end{frame}

\begin{frame}{Lmod}
  \begin{itemize}
    \item Complete Rewrite of the Environment Modules System.
    \item Reads TCL or Lua modulefiles.
    \item Based on the Lua scripting language.
    \item Simple yet powerful with:
      \begin{itemize}
        \item Functions are first class objects.
        \item Simpifies loading/unloading of modules.
        \item Tables combine array and hash seamlessly.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Key Insight (I): \texttt{MODULEPATH}}
  \begin{itemize}
    \item Lmod remembers the current state of \texttt{MODULEPATH}.
    \item If it changes then it unloads any modules not in current
      search path $\Rightarrow$ inactive.
    \item It tries to activate any inactive modules.
    \item It remembers inactive modules.
    \item It continues to attempt to activate any inactive modules on
      future invocations. 
  \end{itemize}
\end{frame}

\begin{frame}{Key Insight (II): \texttt{MODULEPATH}}
  \begin{itemize}
    \item Loading gcc/4.5 and boost/1.47.1
    \item M={\color{blue}/opt/apps/modulefiles}
      \begin{itemize}
        \item Adds \texttt{{\color{blue}\$M}/Compiler/gcc/4.5} to
          \texttt{MODULEPATH}.
        \item Boost: \texttt{{\color{blue}\$M}/Compiler/gcc/4.5/boost/1.47.1}
      \end{itemize}
    \item Unloading gcc/4.5
      \begin{itemize}
        \item Removes \texttt{{\color{blue}\$M}/Compiler/gcc/4.5}
          from \texttt{MODULEPATH}.
        \item Inactivates boost/1.47.1
      \end{itemize}
    \item Loading intel/11.1
      \begin{itemize}
        \item Adds \texttt{{\color{blue}\$M}/Compiler/intel/11.1} to
          \texttt{MODULEPATH}.
        \item Activates Boost: \texttt{{\color{blue}\$M}/Compiler/intel/11.1/boost/1.47.1}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Other Safety Features of Lmod (I)}
  \begin{itemize}
    \item Users can only load one version of a package.
    \item ``\texttt{module load xyz/2.1}'' loads xyz version 2.1
    \item ``\texttt{module load xyz/2.2}'' unloads 2.1, loads 2.2
  \end{itemize}
\end{frame}

\begin{frame}{Other Safety Features of Lmod (II)}
  \begin{itemize}
    \item Lmod adds a new command in modulefiles: \texttt{family("}\emph{name}\texttt{")}
    \item All of our compiler modules have \texttt{family("compiler")}
    \item All of our MPI modules have \texttt{family("MPI")}
    \item Users can only load one compiler or MPI at a time
    \item Powers users can get around this restriction.
  \end{itemize}
\end{frame}

\begin{frame}{Implication of the One Name Rule}
  \begin{itemize}
    \item Other Module installations allow for modules with names:
      \begin{itemize}
        \item mpi/intel\_11\_1/openmpi/1.5
        \item mpi/intel\_11\_1/mvapich2/1.7
      \end{itemize}
    \item Users can get only one \texttt{mpi} module
    \item Use software hierarchy instead!
  \end{itemize}
\end{frame}




\subsection{Searching for Modules}
\label{sec:search}


\begin{frame}{Searching for Modules}
  \begin{itemize}
    \item Two ways to search for modules:
      \begin{itemize}
        \item ``\texttt{module avail}''
        \item ``\texttt{module spider}''
      \end{itemize}
    \item The ``\texttt{avail}''  command reports all ``loadable'' modules.
    \item The ``\texttt{spider}'' command reports all ``possible'' modules.
    \item What is the difference?
  \end{itemize}
\end{frame}

\begin{frame}{Module avail}
  \begin{itemize}
    \item ``avail'' only reports modules that are loadable w/ current
      MPI/Compiler pairing.
    \item A parallel library may not be built for all possible pairings.
    \item Won't always show with avail.
    \item Not all package can be build or work with all compiler/MPI suites.
  \end{itemize}
\end{frame}

\begin{frame}{Module spider}
  \begin{itemize}
    \item Reports all modules for given \texttt{MODULEPATH}.
    \item It recursively searches the tree to find all branches.
    \item Large systems of modules save a cache file that is saved for
      a day.
    \item Three modes:
      \begin{itemize}
        \item module spider - all possible modules no detail.
        \item module spider petsc - all versions of petsc, no detail.
        \item module spider petsc/3.1 - detail.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Module keyword key1 key2 ...}
    \begin{itemize}
      \item
    Modules can have a ``whatis'' description:
    {\tiny
\begin{alltt}
whatis("Name: Abyss")
whatis("Version: 1.2.7")
whatis("Category: computational biology, genomics")
whatis("URL:http://www.bcgsc.ca/platform/bioinfo/software/abyss")
whatis("Description: Assembly By Short Sequences.")
\end{alltt}
    }
  \item {\color{blue}module keyword key1 ...} will report all modules
    with any of the {\color{blue}key}'s.
  \end{itemize}
\end{frame}

\subsection{Installing Lmod}
\label{sec:installing}

\begin{frame}{Installation Overview}
  \begin{itemize}
    \item Chose a place for module tree: ``\texttt{/opt/apps/modulefiles}''
    \item Use configure to override default.
    \item Install lua and Lmod applications.
    \item Place module command in system shell startup.
    \item Possibly modify bash's startup procedure.
    \item Design a default set of modules for your users.
  \end{itemize}
\end{frame}


\begin{frame}{Installing Lmod (I)}
  \begin{itemize}
    \item Download files from lmod.sf.net
      \begin{itemize}
        \item lua-x.y.z.tar.gz
        \item lmod-x.y.z.tar.gz
      \end{itemize}
    \item Assume all ``optional'' packages are in ``\texttt{/opt/apps/}''
    \item Install lua in ``\texttt{/opt/apps/lua/}\emph{x.y.z}''
    \item ``\texttt{\$ ln -s }\emph{x.y.z} \texttt{/opt/apps/lua/lua}''
    \item This way ``\texttt{/opt/apps/lua/lua/bin/lua}'' always points to
      lua independent of version.
  \end{itemize}
\end{frame}

\begin{frame}{Installing Lmod (II)}
  \begin{itemize}
    \item Install Lmod in ``\texttt{/opt/apps/lmod/}\emph{x.y.z}''
    \item ``\texttt{make install}'' creates a symlink from
      ``\emph{x.y.z}'' to lmod.
    \item This way ``\texttt{/opt/apps/lmod/lmod/...}'' always points
      to the latest lmod.
  \end{itemize}
\end{frame}

\begin{frame}{Integrating Lmod into User's Shell (I)}
    We must add the module alias for all user's shells by either link
    or copy:
    \begin{itemize}
      \item \texttt{\$ ln -s /opt/apps/lmod/lmod/init/profile /etc/profile.d/modules.sh}
      \item \texttt{\$ ln -s /opt/apps/lmod/lmod/init/cshrc   /etc/profile.d/modules.csh}
      \item You may have to create ``\texttt{/etc/profile.d}'' first.
  \end{itemize}
\end{frame}

\begin{frame}{Bash Shell startup files}
    \begin{tabular}{|l|l|l|}
        \hline
        ~           & System       & User \\\hline\hline
        login       & /etc/profile & $\sim$/.bash\_profile $\parallel$ $\sim$/.profile, ...\\\hline
        interactive & {\color{red}/etc/bashrc}$^\star$  & $\sim$/.bashrc\\\hline
        non-interactive & \$BASH\_ENV  & ~\\\hline
    \end{tabular}
    ~\\
    ~\\
    $^\star$ Not always built-in!\\
    \$BASH\_ENV points to a file which is run on  non-interactive shells.
\end{frame}

\begin{frame}{Csh Shell startup files}
{\small
    \begin{tabular}{|l|l|l|}
        \hline
        ~           & System       & User \\\hline\hline
        login       & /etc/csh.cshrc \& /etc/csh.login &  $\sim$/.cshrc  \& $\sim$/.login\\\hline
        interactive & /etc/csh.cshrc  & $\sim$/.cshrc\\\hline
        non-interactive & /etc/csh.cshrc & $\sim$/.cshrc~\\\hline
    \end{tabular}
}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Linux /etc/profile}
    {
\begin{verbatim}
if [ -d /etc/profile.d ]; then
  for i in /etc/profile.d/*.sh; do
    if [ -r $i ]; then
      . $i
    fi
  done
fi
\end{verbatim}
    }
\end{frame}


\begin{frame}[fragile]
    \frametitle{Linux /etc/bashrc}
    {
\begin{verbatim}
if ! shopt -q login_shell; then
  if [ -d /etc/profile.d ]; then
    for i in /etc/profile.d/*.sh; do
      if [ -r $i ]; then
        . $i
      fi
    done
  fi
fi
\end{verbatim}
    }
\end{frame}

\begin{frame}[fragile]
    \frametitle{Linux /etc/csh.cshrc}
    {
\begin{verbatim}
if ( -d /etc/profile.d ) then
  set nonomatch
  foreach i ( /etc/profile.d/*.csh )
     if ( -r $i ) then
       if ($?prompt) then
         source $i
       else
         source $i >& /dev/null
       endif
    endif
  end
endif
\end{verbatim}
    }
\end{frame}

\begin{frame}{Rebuilding Bash to use /etc/bashrc}
  \begin{itemize}
    \item By default bash does not read /etc/bashrc
    \item Red Hat, Centos,  Mac OS X, don't read /etc/bashrc
    \item At TACC, we rebuilt bash so that it does read /etc/bashrc
    \item You must patch config-top.h to change bash's behavior.
    \item We want bash interactive shells to behave the same as login shells.
  \end{itemize}
\end{frame}

\begin{frame}{Loading Default Modules}
  \begin{itemize}
    \item At TACC, all users get a default set of module loaded at startup.
    \item In ``\texttt{/etc/profile.d/z96\_login\_modules.sh}:'' \\
      {\color{blue}\texttt{module getdefault default || module load TACC}}
    \item Most users get the ``TACC'' set of modules
    \item We load standard tools, a compiler, and an mpi implementation.
    \item User can replace the default via ``{\color{blue}\texttt{module setdefault}}''
  \end{itemize}
\end{frame}

\begin{frame}{Modules and Package Management at TACC}
  \begin{itemize}
    \item All of the ``optional'' software: compilers, MPI Stacks,
      Libraries, and Applications are installed via the RPM package manager.
    \item We create our optional RPMs with both the software and the
      module files.
    \item Uninstalling a package removes both the software and the
      module that access it.
    \item We use a single parameterized RPM spec file to build all
      compiler/mpi pairings.
  \end{itemize}
\end{frame}

\begin{frame}{Management of Modules}
  \begin{itemize}
    \item Encourage users to use modules with their own software.
    \item Check modulefile syntax errors by running:
       {\color{blue}module spider}
    \item Use {\color{violet}\texttt{prereq("foo","bar")}} instead of
      {\color{violet}\texttt{load("foo","bar")}}
    \item Use  {\color{violet}\texttt{family("compiler")}} and similar
      in your compiler and MPI module files.
  \end{itemize}
\end{frame}

\begin{frame}{Making modules work with setdefault}
  \begin{itemize}
    \item A module file should only be either a manager module or
      a worker module.
      \begin{itemize}
        \item A worker module is one that only sets environment variables.
        \item A manager module loads other modules.
      \end{itemize}
    \item For complicated reasons, setdefault/getdefault requires that
      no module being saved is both a manager and a worker modulefile.
  \end{itemize}
\end{frame}

\subsection{HPC issues}

\begin{frame}{Module usage}
  \begin{itemize}
    \item It is possible to record module usage:
      \begin{itemize}
        \item Record modules loaded at logout time and/or job submission.
        \item Find out what modules are not or under used.
          $\Rightarrow$ removal or upgrade.
        \item Suggest to users of one module to consider using another module.
      \end{itemize}
  \end{itemize}
\end{frame}



\begin{frame}[fragile]
    \frametitle{HPC issues: Root}
  \begin{itemize}
    \item Root should not define the module command or load a default
      set of modules during shell startup.
    \item What if \texttt{/opt/apps/} is unavailable?

  \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{HPC issues: Users}
  \begin{itemize}
    \item Encourage your users to use {\color{blue}module setdefault}
    \item Or users should load their modules via $\sim$/.bashrc or
      $\sim$/.cshrc but wrap them:
    {\small
\begin{verbatim}
    if [ -z “$_READ” –a –z “$ENVIRONMENT” ]; then
      export _READ=1 # Put any module commands here:
      module load git
    fi
\end{verbatim}
}
\item  At TACC: ENVIRONMENT is ``BATCH'' when on a compute node.
\item Otherwise each shell of a user's 8192 process job will try to
  load modules $\Rightarrow$ Parallel file system metadata servers can hang.
  \end{itemize}
\end{frame}




\section{Conclusion}

\begin{frame}{Conclusion}
  \begin{itemize}
    \item Download source from: lmod.sourceforge.net (lmod.sf.net)
    \item Documentation: www.tacc.utexas.edu/tacc-projects/mclay/lmod
  \end{itemize}
\end{frame}

\end{document}
