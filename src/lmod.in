#!@path_to_lua@/lua
-- -*- lua -*-


-- ancient:   the time in seconds when the cache file is considered old
-- shortTime: the time in seconds when building the cache file is quick
--            enough to be computed every time rather than cached.
ancient       = "@ancient@"
shortTime     = "@short_time@"
sysCacheDir   = os.getenv("LMOD_SPIDER_CACHE_DIR") or "@cacheDir@"
ancient       = tonumber(ancient)   or 86400
shortTime     = tonumber(shortTime) or 10.0
BaseShell     = {}
------------------------------------------------------------------------
-- Extract directory location of "lmod" command and add it
-- to the lua search path
------------------------------------------------------------------------

------------------------------------------------------------------------
-- Use command name to add the command directory to the package.path
------------------------------------------------------------------------
local LuaCommandName = arg[0]
local i,j = LuaCommandName:find(".*/")
local LuaCommandName_dir = "./"
if (i) then
   LuaCommandName_dir = LuaCommandName:sub(1,j)
end
package.path = LuaCommandName_dir .. "?.lua;" .. package.path

function cmdDir()
   return LuaCommandName_dir
end

local getenv = os.getenv
local rep    = string.rep

require("myGlobals")
require("strict")
require("firstInPath")
MasterControl = require("MasterControl")
MCP           = {}
mcp           = {}
require("modfuncs")
require("cmdfuncs")
local Dbg     = require("Dbg")
local Version = require("Version")

Usage = [[
module sub-command [args ...]

Help sub-commands:
  help                                   prints this message
  help               modulefile [...]    print help message from module(s)

Loading/Unloading sub-commands:
  add | load         modulefile [...]    Add module(s)
  try-load | try-add modulefile [...]    Add module(s) , do not complain
                                         if not found
  del | rm | unload  modulefile [...]    Remove module(s), do not complain
                                         if not found
  swap | sw | switch modfile1 modfile2   unload modfile1 and load modfile2
  purge                                  unload all modules

Reset environment
  reset                                  Do a module purge and load system defaults

Listing / Searching sub-commands:
  list                                   List loaded modules
  list             s1 s2 ...             List loaded modules that match the s1
                                         pattern or the s2 pattern etc.
  avail | av                             List available modules
  avail | av       string                List available modules that contain
                                         "string".

  spider                                 List all possible modules
  spider           modulefile            List all possible version of that
                                         module file
  spider           string                List all module that contain the
                                         string.  Simple regular expression
                                         supported: "[Mm]pi"
  spider           modulefile/version    Detailed information about that
                                         version of the module
  whatis           modulefile            print whatis information about module
  keyword | key    string                search all name and whatis that contain
                                         "string". Simple regular expression
                                         supported: "^p"

Setting/Getting Default module sub-commands:
  setdefault | sd                        Save the current list of modules
                                         to a file named "default".
  setdefault | sd  filename              Save the current list of modules
                                         to "filename"
  getdefault | gd                        Use the filename "default" to retrieve
                                         previously saved list of modules.
  getdefault | gd  filename              Use the filename "filename" to retrieve
                                         previously saved list of modules.
  listdefault | ld                       list all saved default states.

Miscellaneous sub-commands:
  record                                 save the module table.
  show                modulefile         show the commands in the module file.
  use [-a] [--append] path               Prepend or Append path to MODULEPATH
  unuse path                             remove path from MODULEPATH
  tablelist                              output list of active modules as a table.

----------------------------------------------------------------------------------
See:

   http://www.tacc.utexas.edu/tacc-projects/mclay/lmod

for complete documentation. It contains:

   User Guide                  - How to use.
   Advance User Guide          - How to create you own modules.
   System Administrator Guide  - If you want to install it on your own system.

----------------------------------------------------------------------------------
]]

local concatTbl = table.concat

function version()
   local v = {}
   v[#v + 1] = "\nModules based on Lua: Version " .. Version.name().."\n"
   v[#v + 1] = "    by Robert McLay mclay@tacc.utexas.edu\n\n"
   return concatTbl(v,"")
end


require("border")

require("serializeTbl")
require("fileOps")
require("string_split")
require("string_trim")
BaseShell          = require("BaseShell")
local ColumnTable  = require("ColumnTable")
local Spider       = require("Spider")
local Var          = require("Var")
local lfs          = require("lfs")
local posix        = require("posix")

local Options = require("Options")


function None()
   print ("None")
   FooBar=1
end

local function Avail(...)
   local master = Master:master()
   local a = {}
   for _,v in ipairs{...} do
      a[#a + 1] = v
   end
   master.avail(a)
end

local function Display(...)
end

local function Update()
   local master = Master:master()
   master:reloadAll()
end

local function List(...)
   local mt = MT:mt()

   local totalA = mt:listTotal()
   if (#totalA < 1) then
      local dbg = Dbg:dbg()
      dbg.warning("No modules installed\n")
      return
   end

   local wanted = {}
   for i,v in ipairs{...} do
      wanted[i] = v
   end


   local msg     = "Currently Loaded Modules"
   local activeA = mt:listActive()
   local t       = {}
   local msg2    = ":"

   if (#wanted == 0) then
      wanted[1] = ".*"
   else
      msg2 = " Matching: " .. table.concat(wanted," or ")
   end

   io.stderr:write(msg,msg2,"\n")
   local k = 0
   for i = 1, #activeA do
      local m = mt:modFullNameActive(activeA[i])
      for j = 1, #wanted do
         local p = wanted[j]
         if (m:find(p,1,true) or m:find(p)) then
            k = k + 1
            t[#t + 1] = "  " .. k .. ") " .. m
         end
      end
   end

   if (k == 0) then
      io.stderr:write("  None found.\n")
   else
      local ct = ColumnTable:new{tbl=t,prt=prtErr,gap=0}
      ct:print_tbl()
   end
   t = {}
   k = 0

   local k = 0
   for i = 1, #totalA do
      local v = totalA[i]
      if (not mt:haveModuleAnyActive(v)) then
         local m = mt:modFullNameTotal(v)
         for j = 1, #wanted do
            local p = wanted[j]
            if (m:find(p,1,true) or m:find(p)) then
               k = k + 1
               t[#t + 1] = "  " .. k .. ") " .. m
            end
         end
      end
   end

   if (#t > 0) then
      io.stderr:write("Inactive Modules",msg2,"\n")
      local ct = ColumnTable:new{tbl=t,prt=prtErr,gap=0}
      ct:print_tbl()
   end
end

local function TableList()
   local mt = MT:mt()

   local t = {}
   local activeA = mt:listActive()
   for i,v  in ipairs(activeA) do
      local w = mt:modFullNameActive(v)
      local _, _, name, version = w:find("([^/]*)/?(.*)")
      t[name] = version
   end
   local s = serializeTbl{name="activeList",indent=true, value=t}
   io.stderr:write(s,"\n")

end

function Reset()
   local dbg    = Dbg:dbg()
   dbg.start("Reset()")
   Purge()
   local default = os.getenv("LMOD_SYSTEM_DEFAULT_MODULES") or ""
   dbg.print("default: ",default,"\n")

   default = default:trim()
   default = default:gsub(" *, *",":")
   default = default:gsub(" +",":")

   local a = {}
   for m in default:split(":") do
      dbg.print("m: ",m,"\n")
      a[#a + 1] = m
   end
   UsrLoad(unpack(a))
   dbg.fini()
end

local function localvar(localvarA)
   local dbg = Dbg:dbg()
   for _, v in ipairs(localvarA) do
      local i = v:find("=")
      if (i) then
         local k  = v:sub(1,i-1)
         if (varTbl[k] == nil) then
            varTbl[k] = Var:new(k)
         end
         local vv = v:sub(i+1)
         dbg.print("setLocal(\"",k,"\", \"",vv,"\")\n")
         varTbl[k]:setLocal(vv)
      end
   end
end



add	     = None
rm	     = None
use          = None
unuse        = None
prtHdr       = None
avail        = Avail
list         = List

ModuleName = ""
ModuleFn   = ""

function Use(...)
   local dbg = Dbg:dbg()
   local mt  = MT:mt()
   local a = {}
   local op = MCP.prepend_path
   dbg.start("use(", concatTbl({...},", "),")")

   for _,v in ipairs{...} do
      local w = v:lower()
      if (w == "-a" or w == "--append" ) then
         op = MCP.append_path
      else
         a[#a + 1] = v
      end
   end
   for _,v in ipairs(a) do
      v = abspath(v)
      if (v) then
         op(MCP, ModulePath, v)
         op(MCP, DfltModPath, v)
      end
   end
   mt:buildBaseMpathA(varTbl[DfltModPath]:expand())
   mt:reloadAllModules()
   dbg.fini()
end

function UnUse(...)
   local dbg = Dbg:dbg()
   local mt  = MT:mt()
   dbg.start("unuse(", concatTbl({...},", "),")")
   for _,v in ipairs{...} do
      MCP:remove_path( ModulePath,v)
      MCP:remove_path( DfltModPath,v)
   end
   mt:buildBaseMpathA(varTbl[DfltModPath]:expand())
   mt:reloadAllModules()
   dbg.fini()
end

function Show(...)
   local dbg    = Dbg:dbg()
   local master = Master:master()
   dbg.start("Show(", concatTbl({...},", "),")")

   mcp = MasterControl.build("show")
   dbg.print("Setting mpc to ", mcp:name(),"\n")

   prtHdr       = function()
                     io.stderr:write("------------------------------------------------------------\n")
                     io.stderr:write("   ",ModuleFn,":\n")
                     io.stderr:write("------------------------------------------------------------\n")
                  end

   master:access(...)
   dbg.fini()

end

function Access(...)
   local dbg    = Dbg:dbg()
   local master = Master:master()
   dbg.start("Access(", concatTbl({...},", "),")")
   mcp = MasterControl.build("access")
   dbg.print("Setting mpc to ", mcp:name(),"\n")

   local n = select('#',...)
   if (n < 1) then
      io.stderr:write(Usage,"\n")
      io.stderr:write(version())
      os.exit(1)
   end

   master:access(...)
   dbg.fini()
end

function Help(...)
   local dbg = Dbg:dbg()
   help    = function (...)
      io.stderr:write(...)
      io.stderr:write("\n")
   end

   prtHdr  = function()
                io.stderr:write("\n")
                io.stderr:write("----------- Module Specific Help for \"" .. ModuleName .. "\"------------------\n")
             end

   Access(...)
end

function Whatis(...)
   local dbg = Dbg:dbg()
   whatis  = function(msg)
                local nm     = ModuleName or ""
                local l      = nm:len()
                local nblnks
                if (l < 20) then
                   nblnks = 20 - l
                else
                   nblnks = l + 2
                end
                local prefix = nm .. string.rep(" ",nblnks) .. ": "
                io.stderr:write(prefix, msg, "\n")
             end
   prtHdr    = dbg.quiet
   Access(...)
end

function TryUsrLoad(...)
   local master = Master:master()
   local mt     = MT:mt()
   local dbg    = Dbg:dbg()

   dbg.start("TryUsrLoad(",concatTbl({...},", "),")")
   dbg:deactivateWarning()
   UsrLoad(...)
   dbg.fini()
end

function UsrLoad(...)
   local master = Master:master()
   local mt     = MT:mt()
   local dbg    = Dbg:dbg()

   dbg.start("UsrLoad(",concatTbl({...},", "),")")
   local a = {}
   for _,v in ipairs{...} do
      if (v:sub(1,1) == "-") then
         MCP:unload(v:sub(2))
      else
         if (v:sub(1,1) == "+") then
            v = v:sub(2)
         end
         a[#a + 1] = v
         if (mt:haveModuleAnyActive(v)) then
            MCP:unload(v)
         end
      end
   end

   local mcp_old = mcp
   mcp           = MCP
   local b       = mcp:load(unpack(a))
   mcp           = mcp_old

   dbg.fini()
   return b
end

function UnLoad(...)
   local dbg    = Dbg:dbg()
   dbg.start("UnLoad(",concatTbl({...},", "),")")
   MCP:unload(...)
   dbg.fini()
end


local function SetDefault(...)
   local mt   = MT:mt()
   local dbg  = Dbg:dbg()
   local a    = select(1, ...) or "default"
   local path = pathJoin(os.getenv("HOME"), LMODdir)
   dbg.start("SetDefault(",concatTbl({...},", "),")")

   local aa = mt:safeToSaveActive()

   if (#aa > 0) then
      dbg.warning("Unable to save module state as a \"default\"\n",
                  "The following module(s):\n",
                  "  ",concatTbl(aa,", "),"\n",
                  "mix load statements with setting of environment variables.\n")
      dbg.fini()
      return
   end

   if (not isDir(path)) then
      os.execute("mkdir ".. path)
   end
   path = pathJoin(path, a)
   if (isFile(path)) then
      os.rename(path, path .. "~")
   end
   mt:assignHashSumActive()
   mt.active.hash = mt.active._hash
   serializeTbl{name=mt:name(), value=mt, fn = path, indent = true}
   mt.active.hash = nil
   dbg.fini()
end

local function GetDefault(...)
   local mt   = MT:mt()
   local dbg  = Dbg:dbg()
   local a    = select(1, ...) or "default"
   local path = pathJoin(os.getenv("HOME"), ".lmod.d", a)
   dbg.start("GetDefault(",a,")")
   mt:getMTfromFile(path)
   dbg.fini()
end

local function FindDefaults(a,path)
   for file in lfs.dir(path) do
      if (file:sub(1,1) ~= "." and file:sub(-1) ~= "~") then
         local f = pathJoin(path,file)
         if (isDir(f)) then
            FindDefaults(a,f)
         else
            a[#a+1] = f
         end
      end
   end
end

local function ListDefault(...)
   local mt   = MT:mt()
   local dbg  = Dbg:dbg()
   local path = pathJoin(os.getenv("HOME"), LMODdir)
   local i    = 0

   local a = {}
   local b = {}

   FindDefaults(b,path)
   for k = 1,#b do
      local name = b[k]
      local i,j  = name:find(path,1,true)
      if (i) then
         name = name:sub(j+2)
      end
      a[#a+1] = "  " .. k .. ") " .. name
   end

   if (#a > 0) then
      io.stderr:write("Possible defaults:\n")
      local ct = ColumnTable:new{tbl=a,prt=prtErr,gap=0}
      ct:print_tbl()
   end
end

local function Swap(...)
   local dbg = Dbg:dbg()
   local a = select(1, ...) or ""
   local b = select(2, ...) or ""
   local s = {}

   dbg.start("Swap(",concatTbl({...},", "),")")

   local n = select("#", ...)
   if (n ~= 2) then
      LmodError("Wrong number of arguments to swap.\n")
   end

   local mt     = MT:mt()
   if (not mt:haveModuleAnyTotal(a)) then
      LmodError("Swap failed: \"",a,"\" is not loaded.\n")
   end

   local mcp_old = mcp
   mcp           = MCP
   mcp:unload(a)
   local aa = mcp:load(b)
   if (not aa[1]) then
      LmodError("Swap failed.\n")
   end
   mcp = mcp_old
   dbg.fini()
end

function UUIDString(epoch)
   local ymd  = os.date("*t", epoch)

   --                                y    m    d    h    m    s
   local uuid_date = string.format("%d_%02d_%02d_%02d_%02d_%02d", 
                                   ymd.year, ymd.month, ymd.day, 
                                   ymd.hour, ymd.min,   ymd.sec)
   
   local uuid_str  = capture("uuidgen"):sub(1,-2)
   local uuid      = uuid_date .. "-" .. uuid_str

   return uuid
end

local function epoch()
   if (posix.gettimeofday) then
      local t1, t2 = posix.gettimeofday()
      return t1 + t2*1.0e-6
   else
      return os.time()
   end
end

function getModuleT()

   local dbg        = Dbg:dbg()
   local mt         = MT:mt()
   local moduleT    = {}
   local HOME       = os.getenv("HOME") or ""
   local cacheDir   = pathJoin(HOME,".lmod.d",".cache")
   local errRtn     = LmodError
   local message    = LmodMessage
   local cacheFileA = {
      { file = pathJoin(cacheDir,   "moduleT.lua"),     fileT = "your"  },
      { file = pathJoin(sysCacheDir,"moduleT.lua"),     fileT = "system"},
      { file = pathJoin(sysCacheDir,"moduleT.old.lua"), fileT = "system"},
   }
   local userModuleTFN = pathJoin(cacheDir,"moduleT.lua")

   local buildModuleT = true

   dbg.start("getModuleT()")

   local mpath = mt:getBaseMPATH()
   if (mpath == nil) then
     LmodError("The Env Variable: \"", DfltModPath, "\" is not set\n")
   end
   local moduleDirA = {}
   for path in mpath:split(":") do
      moduleDirA[#moduleDirA+1] = path
   end

   local moduleTFN   = nil
   local fileT       = nil
   for i = 1,#cacheFileA do
      local f = cacheFileA[i].file
      dbg.print("cacheFile: ",f,"\n")
      if (isFile(f)) then
         local attr     = lfs.attributes(f)
         local timeDiff = os.time() - attr.modification
         buildModuleT   = timeDiff > ancient  -- rebuild if older than a day
         dbg.print("timeDiff: ",timeDiff," buildModuleT: ", tostring(buildModuleT),"\n")
         if (not buildModuleT) then
            assert(loadfile(f))()
            local defaultMpathA = _G.defaultMpathA
            if (#moduleDirA ~= #defaultMpathA) then
               buildModuleT = true -- rebuild because the number of dirs has changed.
               dbg.print("(2) buildModuleT: ", tostring(buildModuleT),"\n")
            else
               buildModuleT = false
               for i = 1,#moduleDirA do
                  if (moduleDirA[i] ~= defaultMpathA[i]) then
                     buildModuleT = true
                     break
                  end
               end
               dbg.print("(3) buildModuleT: ", tostring(buildModuleT),"\n")
            end
            dbg.print("(4) buildModuleT: ", tostring(buildModuleT),"\n")
            if (not buildModuleT) then
               moduleTFN    = f
               fileT        = cacheFileA[i].fileT
               break
            end
         end
      end
   end

   if (moduleTFN) then
      io.stderr:write("Using ",fileT," spider cache file\n")
   end

   if (buildModuleT) then
      LmodError    = dbg.quiet
      LmodMessage  = dbg.quiet
      io.stderr:write("Rebuilding cache file, please wait ...")
      local t1 = epoch()
      Spider.findAllModules(moduleDirA, moduleT)
      local t2 = epoch()
      io.stderr:write(" done\n")
      LmodError    = errRtn
      LmodMessage  = message
      dbg.print("t2-t1: ",t2-t1, " shortTime: ", shortTime, "\n")
      if (t2 - t1 > shortTime) then
         mkdir_recursive(cacheDir)
         local s0 = "-- Date: " .. os.date("%c",os.time()) .. "\n"
         local s1 = serializeTbl{name="defaultMpathA",value=moduleDirA,indent=true}
         local s2 = serializeTbl{name="moduleT",      value=moduleT,   indent=true}
         local f  = io.open(userModuleTFN,"w")
         f:write(s0,s1,s2)
         f:close()
         dbg.print("Wrote: ",userModuleTFN,"\n")
      else
         -- remove cache file if old
         if (isFile(userModuleTFN)) then
            posix.unlink(userModuleTFN);
            dbg.print("Deleted: ",userModuleTFN,"\n")
         else
            dbg.print("Not writing cache file.\n")
         end
      end

   else
      moduleT = _G.moduleT
   end
   dbg.fini()
   return moduleT
end


function RecordCmd()
   local dbg = Dbg:dbg()
   dbg.start("RecordCmd()")
   local mt   = MT:mt()
   local s    = serializeTbl{indent=true, name="_ModuleTable_", value=_ModuleTable_}
   local uuid = UUIDString(epoch())
   local fn   = pathJoin(getenv("HOME"), ".lmod.d", ".save", uuid .. ".lua")

   local d = dirname(fn)
   if (not isDir(d)) then
      mkdir_recursive(d)
   end 

   local f = io.open(fn,"w")
   if (f) then
      f:write(s)
      f:close()
   end
   dbg.fini()
end


function SpiderCmd(...)
   local dbg = Dbg:dbg()
   dbg.start("SpiderCmd(", concatTbl({...},", "),")")
   mcp           = MasterControl.build("spider")
   dbg.print("Setting mpc to ", mcp:name(),"\n")
   local moduleT = getModuleT()

   local s
   local dbT = {}
   local errorRtn = LmodError
   Spider.buildSpiderDB({"default"},moduleT, dbT)
   LmodError = errorRtn

   local arg = {n=select('#',...),...}

   if (arg.n < 1) then
      s = Spider.Level0(dbT)
   else
      local a = {}
      local help = false
      for i = 1, arg.n do
         if (i == arg.n) then help = true end
         a[#a+1] = Spider.spiderSearch(dbT, arg[i], help)
      end
      s = concatTbl(a,"\n")
   end
   io.stderr:write(s,"\n")
   dbg.fini()
end

function Keyword(...)
   local dbg    = Dbg:dbg()
   dbg.start("Keyword(",concatTbl({...},","),")")
   mcp          = MasterControl.build("spider")
   dbg.print("Setting mpc to ", mcp:name(),"\n")

   local master = Master:master()

   local moduleT = getModuleT()
   local s
   local dbT = {}
   Spider.searchSpiderDB({...},{"default"},moduleT, dbT)
   local a = {}
   local ia = 0

   local banner = border(0)

   ia = ia+1; a[ia] = "\n"
   ia = ia+1; a[ia] = banner
   ia = ia+1; a[ia] = "The following modules match your search criteria: \""
   ia = ia+1; a[ia] = concatTbl({...},"\", \"")
   ia = ia+1; a[ia] = "\"\n"
   ia = ia+1; a[ia] = banner
   ia = ia+1; a[ia] = "\n"

   Spider.Level0Helper(dbT,a)
   io.stderr:write(concatTbl(a,""))
   dbg.fini()

end


local __expert = false

function expert()
   if (__expert == false) then
      __expert = getenv("LMOD_EXPERT")
   end
   return __expert
end

Master = require("Master")
MT     = require("MT")

function main()
   
   local loadTbl      = { name = "load",        checkMPATH = true,  cmd = UsrLoad     }
   local tryAddTbl    = { name = "try-add",     checkMPATH = true,  cmd = TryUsrLoad  }
   local unloadTbl    = { name = "unload",      checkMPATH = true,  cmd = UnLoad      }
   local swapTbl      = { name = "swap",        checkMPATH = true,  cmd = Swap        }
   local purgeTbl     = { name = "purge",       checkMPATH = true,  cmd = Purge       }
   local resetTbl     = { name = "reset",       checkMPATH = true,  cmd = Reset       }
   local availTbl     = { name = "avail",       checkMPATH = false, cmd = Avail       }
   local listTbl      = { name = "list",        checkMPATH = false, cmd = List        }
   local tblLstTbl    = { name = "tablelist",   checkMPATH = false, cmd = TableList   }
   local helpTbl      = { name = "help",        checkMPATH = false, cmd = Help        }
   local whatisTbl    = { name = "whatis",      checkMPATH = false, cmd = Whatis      }
   local showTbl      = { name = "show",        checkMPATH = false, cmd = Show        }
   local useTbl       = { name = "use",         checkMPATH = true,  cmd = Use         }
   local unuseTbl     = { name = "unuse",       checkMPATH = true,  cmd = UnUse       }
   local updateTbl    = { name = "update",      checkMPATH = true,  cmd = Update      }
   local keywordTbl   = { name = "keyword",     checkMPATH = false, cmd = Keyword     }
   local setDefTbl    = { name = "setdefault",  checkMPATH = false, cmd = SetDefault  }
   local getDefTbl    = { name = "getdefault",  checkMPATH = false, cmd = GetDefault  }
   local listDefTbl   = { name = "listdefault", checkMPATH = false, cmd = ListDefault }
   local spiderTbl    = { name = "spider",      checkMPATH = true,  cmd = SpiderCmd   }
   local recordTbl    = { name = "record",      checkMPATH = false, cmd = RecordCmd   }

   local cmdTbl = {
      ["try-add"]  = tryAddTbl,
      ["try-load"] = tryAddTbl,
      add          = loadTbl,
      apropos      = keywordTbl,
      av           = availTbl,
      avail        = availTbl,
      del          = unloadTbl,
      delete       = unloadTbl,
      dis          = showTbl,
      display      = showTbl,
      era          = unloadTbl,
      erase        = unloadTbl,
      gd           = getDefTbl,
      getd         = getDefTbl,
      getdefault   = getDefTbl,
      help         = helpTbl,
      key          = keywordTbl,
      keyword      = keywordTbl,
      ld           = listDefTbl,
      li           = listTbl,
      list         = listTbl,
      listdefault  = listDefTbl,
      lo           = loadTbl,
      load         = loadTbl,
      purge        = purgeTbl,
      record       = recordTbl,
      refr         = updateTbl,
      refresh      = updateTbl,
      reload       = updateTbl,
      remov        = unloadTbl,
      remove       = unloadTbl,
      reset        = resetTbl,
      rm           = unloadTbl,
      sd           = setDefTbl,
      setd         = setDefTbl,
      setdefault   = setDefTbl,
      show         = showTbl,
      spider       = spiderTbl,
      sw           = swapTbl,
      swap         = swapTbl,
      switch       = swapTbl,
      tablelist    = tblLstTbl,
      unlo         = unloadTbl,
      unload       = unloadTbl,
      unuse        = unuseTbl,
      update       = updateTbl,
      use          = useTbl,
      wh           = whatisTbl,
      whatis       = whatisTbl,
   }

   local dbg  = Dbg:dbg()
   dbg.set_prefix("Lmod")

   MCP = MasterControl.build("load")


   --local lTbl = { whatis = dbg.quiet, help = dbg.quiet,
   --               setenv = Set,       unsetenv = Unset,
   --               prepend_path = Prepend_path, append_path = Append_path, remove_path = Remove_path,
   --               set_alias    = SetAlias,     unset_alias = UnSetAlias,  family      = SetFamily,
   --               load         = Load,         unload      = UnLoad,      mode        = ModeLoad,
   --               prereq       = Prereq,       conflict    = Conflict,    inherit     = InheritModule,
   --               display      = Display,      try_load    = TryLoad,
   --}
   --
   --local unTbl = { whatis = dbg.quiet, help = dbg.quiet,
   --                setenv = Unset,     unsetenv = BadUnset,
   --                prepend_path = Remove_path,  append_path = Remove_path,   remove_path = BadRemove_path,
   --                set_alias    = UnSetAlias,   unset_alias = BadUnSetAlias, family      = UnsetFamily,
   --                load         = UnLoad,       unload      = BadUnLoad,     mode        = ModeUnload,
   --                prereq       = dbg.quiet,    conflict    = dbg.quiet,     inherit     = InheritModule,
   --                display      = dbg.quiet,    try_load    = UnLoad,
   --}
   --
   --for k in pairs(lTbl) do
   --   LoadTbl[k] = lTbl[k]
   --end
   --
   --for k in pairs(unTbl) do
   --   UnLoadTbl[k] = unTbl[k]
   --end

   local shell = barefilename(arg[1])
   table.remove(arg,1)


   local arg_str = concatTbl(arg," ")
   local options = Options:options(Usage)

   if (options.debug or options.dbglvl) then
      dbg:activateDebug(options.dbglvl or 1)
   end

   dbg.start("lmod(", arg_str,")")
   MCP = MasterControl.build("load")
   mcp = MasterControl.build("load")
   dbg.print("Setting mpc to ", mcp:name(),"\n")
   localvar(options.localvarA)

   local cmdName = options.pargs[1]
   table.remove(options.pargs,1)

   ------------------------------------------------------------
   -- Must output local variables even when there is the command
   -- is not a valid command
   --
   -- So set [[checkMPATH]] to false by default and re-define when there
   -- is a valid command:

   local checkMPATH = false
   if (cmdTbl[cmdName] ) then
      checkMPATH = cmdTbl[cmdName].checkMPATH
   end

   -- Create the [[master]] object

   local master = Master:master(checkMPATH)
   master.shell = BaseShell.build(shell)
   local mt     = MT:mt()

   -- Output local vars
   master.shell:expand(varTbl)

   -- if Help was requested then quit.
   if (options.Optiks_help) then os.exit(0) end

   -- print version and quit if requested.
   if (options.version) then
      io.stderr:write(version())
      os.exit(0)
   end

   -- Now quit if command is unknown.

   if (cmdTbl[cmdName] == nil) then
      io.stderr:write(version())
      io.stderr:write(Usage,"\n")
      LmodErrorExit()
   end

   if (cmdTbl[cmdName]) then
      local cmd = cmdTbl[cmdName].cmd
      cmdName   = cmdTbl[cmdName].name
      dbg.print("cmd name: ", cmdName,"\n")
      cmd(unpack(options.pargs))
   end

   -- Recompute any inactive modules. Print out if changed
   mt:changeInactive()

   -- Print out modules that have been reloaded.
   master:prtReloadT()

   -- Store the Module table in "_ModuleTable_" env. var.
   local n        = mt:name()
   local oldValue = master.shell:getMT() or ""
   local value    = mt:serializeTbl()

   if (oldValue ~= value) then
      varTbl[n] = Var:new(n)
      varTbl[n]:set(value)
   end
   dbg.fini()

   -- Output all newly created path and variables.
   master.shell:expand(varTbl)

   if (dbg.warningCalled() and not expert() ) then
      LmodErrorExit()
   end
end

main()
